<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ê†ºÊ†º‰∏çÂÖ• Blokus (Á≤æÊ∫ñËß∏ÊéßÁâà)</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --p1-color: #2980b9; /* Ëóç */
            --p2-color: #f1c40f; /* ÈªÉ */
            --p3-color: #c0392b; /* Á¥Ö */
            --p4-color: #27ae60; /* Á∂† */
            --grid-line: #ccc;
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            font-family: "Microsoft JhengHei", sans-serif;
            height: 100vh; overflow: hidden;
            touch-action: none; user-select: none;
            display: flex; flex-direction: column;
        }

        #app-layout { display: flex; width: 100%; height: 100%; overflow: hidden; }

        .side-column {
            width: 20%; min-width: 120px;
            display: flex; flex-direction: column;
            background: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.05); z-index: 5;
        }

        .player-panel {
            flex: 1; display: flex; flex-direction: column;
            border-top: 1px solid #ddd; border-bottom: 1px solid #ddd;
            transition: all 0.3s; position: relative; overflow: hidden;
        }
        .player-panel.active { opacity: 1; background: #fff; border: 2px solid #555; transform: scale(1.02); z-index: 10; }
        .player-panel.inactive { opacity: 0.5; filter: grayscale(0.6); pointer-events: none; border: none; }

        .panel-header {
            padding: 8px; text-align: center; color: white; font-weight: bold; font-size: 0.9rem;
            display: flex; justify-content: space-between;
        }
        #p1-panel .panel-header { background: var(--p1-color); }
        #p2-panel .panel-header { background: var(--p2-color); color:#333; }
        #p3-panel .panel-header { background: var(--p3-color); }
        #p4-panel .panel-header { background: var(--p4-color); }

        .tray-grid {
            flex: 1; padding: 5px; overflow-y: auto;
            display: grid; grid-template-columns: repeat(auto-fill, minmax(38px, 1fr));
            gap: 4px; align-content: start;
        }

        .piece-item {
            aspect-ratio: 1; border: 1px solid #eee; border-radius: 4px;
            position: relative; cursor: pointer; background: #fafafa;
        }
        .piece-item.selected { background: #eee; border-color: #333; box-shadow: inset 0 0 5px rgba(0,0,0,0.1); }
        .piece-item canvas {
            width: 90% !important; height: 90% !important;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #center-panel {
            flex: 1; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: #eef2f3; position: relative; padding: 5px;
        }

        .game-info {
            display: flex; gap: 10px; margin-bottom: 10px;
            background: rgba(255,255,255,0.9); padding: 5px 15px; border-radius: 20px;
            font-size: 0.9rem; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .score-badge { padding: 2px 6px; border-radius: 8px; color: white; min-width: 30px; text-align: center; }

        canvas#mainCanvas {
            background-color: white; border-radius: 4px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            max-width: 98%; max-height: 80vh;
        }

        /* È†êË¶ΩË¶ñÁ™ó */
        #preview-overlay {
            position: absolute; width: 130px;
            background: transparent; border: 3px solid rgba(255,255,255,0.9);
            border-radius: 10px; padding: 8px;
            display: flex; flex-direction: column; align-items: center;
            opacity: 0; visibility: hidden; z-index: 100;
            top: 50%; transform: translateY(-50%); transition: opacity 0.2s;
            pointer-events: auto;
        }
        #preview-overlay.show { opacity: 1; visibility: visible; }
        #preview-overlay.p1-border { border-left: 6px solid var(--p1-color); left: 10px; }
        #preview-overlay.p2-border { border-right: 6px solid var(--p2-color); right: 10px; left: auto; }
        #preview-overlay.p3-border { border-right: 6px solid var(--p3-color); right: 10px; left: auto; }
        #preview-overlay.p4-border { border-left: 6px solid var(--p4-color); left: 10px; }

        .overlay-controls { display: flex; gap: 5px; width: 100%; margin-top: 5px; }
        .overlay-btn { flex: 1; padding: 8px 0; border: 1px solid #ccc; background: rgba(255,255,255,0.9); border-radius: 5px; font-size: 16px; cursor: pointer; }
        .btn-pass { flex: 0.6; background: #fff0f0; color: #c0392b; border-color: #e74c3c; }

        #msg-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white; padding: 15px 30px;
            border-radius: 10px; font-size: 1.5rem; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 200;
        }

        .modal-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 300;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; color: white;
        }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }
        .result-box { background: white; color: #333; padding: 25px; border-radius: 10px; text-align: center; max-width: 90%; width: 400px; }
        
        .rules-btn { position: absolute; top: 10px; right: 10px; width: 36px; height: 36px; border-radius: 50%; border: none; background: #34495e; color: white; font-weight: bold; font-size: 20px; cursor: pointer; z-index: 50; }

        @media (max-width: 900px) and (orientation: portrait) {
            #app-layout { flex-direction: column; }
            .side-column { width: 100%; height: 12%; flex-direction: row; order: 1; border: none; }
            #right-column { order: 3; }
            #center-panel { order: 2; height: 76%; }
            .player-panel { height: 100%; border: none; border-right: 1px solid #ccc; }
            .tray-grid { display: flex; overflow-x: auto; flex-direction: row; white-space: nowrap; align-items: center; }
            #preview-overlay.p1-border, #preview-overlay.p2-border, #preview-overlay.p3-border, #preview-overlay.p4-border {
                top: 50%; left: 50%; transform: translate(-50%, -50%); width: 160px; border: 4px solid white;
            }
        }
    </style>
</head>
<body>

<div id="app-layout">
    <div id="left-column" class="side-column">
        <div id="p1-panel" class="player-panel">
            <div class="panel-header"><span>P1(Ëóç)</span><span id="s1-mini">89</span></div>
            <div id="tray-p1" class="tray-grid"></div>
        </div>
        <div id="p4-panel" class="player-panel">
            <div class="panel-header"><span>P4(Á∂†)</span><span id="s4-mini">89</span></div>
            <div id="tray-p4" class="tray-grid"></div>
        </div>
    </div>

    <div id="center-panel">
        <div class="game-info">
            <div class="score-badge" style="background:var(--p1-color)">P1:<span id="s1">89</span></div>
            <div class="score-badge" style="background:var(--p2-color);color:#333">P2:<span id="s2">89</span></div>
            <div class="score-badge" style="background:var(--p3-color)">P3:<span id="s3">89</span></div>
            <div class="score-badge" style="background:var(--p4-color)">P4:<span id="s4">89</span></div>
            <button onclick="game.manualPass()" style="background:#e74c3c;color:white;border:none;border-radius:50%;width:30px;height:30px;margin-left:5px;">üè≥Ô∏è</button>
        </div>

        <button class="rules-btn" onclick="document.getElementById('rules-modal').classList.add('show')">?</button>
        <canvas id="mainCanvas"></canvas>

        <div id="preview-overlay">
            <div style="font-size:12px;color:#333;margin-bottom:5px;font-weight:bold;text-shadow:0 0 2px white;">Áï∂ÂâçÈÅ∏Êìá</div>
            <canvas id="previewCanvas"></canvas>
            <div class="overlay-controls">
                <button class="overlay-btn" onclick="game.rotateSelected()">üîÑ</button>
                <button class="overlay-btn" onclick="game.flipSelected()">‚ÜîÔ∏è</button>
                <button class="overlay-btn btn-pass" onclick="game.manualPass()">üè≥Ô∏è</button>
            </div>
        </div>

        <div id="msg-overlay">P1 ÂõûÂêà</div>

        <div id="rules-modal" class="modal-overlay" onclick="if(event.target===this)this.classList.remove('show')">
            <div class="result-box">
                <h3>üìú ÈÅäÊà≤Ë¶èÂâá</h3>
                <ul style="text-align:left;padding-left:20px;line-height:1.6;color:#555">
                    <li><strong>Ëµ∑ÊâãÔºö</strong>ÂøÖÈ†àËìã‰ΩèËßíËêΩËµ∑Èªû„ÄÇ</li>
                    <li><strong>ÈÄ£ÁµêÔºö</strong>Êñ∞Ê£ãÂ≠êÈúÄËàáÂêåËâ≤Ê£ãÂ≠ê„ÄåËßíÂ∞çËßí„ÄçÁõ∏ÈÄ£„ÄÇ</li>
                    <li><strong>ÊéíÊñ•Ôºö</strong>ÂêåËâ≤Ê£ãÂ≠êÁµïÂ∞ç„Äå‰∏çËÉΩÈÇäÂ∞çÈÇä„Äç„ÄÇ</li>
                    <li><strong>Áç≤ÂãùÔºö</strong>Ââ©È§òÊ†ºÂ≠êÊúÄÂ∞ëËÄÖË¥è„ÄÇ</li>
                </ul>
                <button style="background:#34495e;color:white;border:none;padding:10px 30px;border-radius:5px;" onclick="document.getElementById('rules-modal').classList.remove('show')">‰∫ÜËß£</button>
            </div>
        </div>

        <div id="game-over-modal" class="modal-overlay">
            <div class="result-box">
                <h2 id="winner-msg">ÈÅäÊà≤ÁµêÊùü</h2>
                <div id="final-scores" style="margin:20px 0;"></div>
                <button style="background:#2980b9;color:white;border:none;padding:10px 30px;border-radius:5px;" onclick="location.reload()">ÂÜç‰æÜ‰∏ÄÂ±Ä</button>
            </div>
        </div>
    </div>

    <div id="right-column" class="side-column">
        <div id="p2-panel" class="player-panel">
            <div class="panel-header"><span>P2(ÈªÉ)</span><span id="s2-mini">89</span></div>
            <div id="tray-p2" class="tray-grid"></div>
        </div>
        <div id="p3-panel" class="player-panel">
            <div class="panel-header"><span>P3(Á¥Ö)</span><span id="s3-mini">89</span></div>
            <div id="tray-p3" class="tray-grid"></div>
        </div>
    </div>
</div>

<script>
const SHAPES = [
    [[0,0]], [[0,0],[0,1]], [[0,0],[0,1],[0,2]], [[0,0],[0,1],[1,0]], 
    [[0,0],[0,1],[0,2],[0,3]], [[0,0],[0,1],[1,0],[1,1]], [[0,0],[0,1],[0,2],[1,1]], 
    [[0,0],[0,1],[0,2],[1,2]], [[0,0],[0,1],[1,1],[1,2]], [[0,0],[0,1],[0,2],[0,3],[0,4]], 
    [[0,0],[0,1],[0,2],[0,3],[1,3]], [[0,0],[0,1],[0,2],[0,3],[1,2]], [[0,0],[1,0],[1,1],[2,1],[3,1]], 
    [[0,0],[0,1],[1,0],[1,1],[0,2]], [[0,0],[0,1],[0,2],[1,0],[1,2]], [[0,0],[0,1],[0,2],[1,0],[2,0]], 
    [[0,0],[0,1],[1,1],[1,2],[2,2]], [[0,0],[0,1],[0,2],[1,1],[2,1]], [[1,0],[0,1],[1,1],[2,1],[1,2]], 
    [[0,0],[0,1],[1,1],[2,1],[2,2]], [[0,1],[1,1],[1,0],[1,2],[2,0]] 
];

const CONFIG = {
    gridSize: 20, 
    startPoints: [{r:0,c:0}, {r:0,c:19}, {r:19,c:19}, {r:19,c:0}],
    colors: { 0:'#fff', 1:'#2980b9', 2:'#f1c40f', 3:'#c0392b', 4:'#27ae60', grid:'#ddd', valid:'rgba(46,204,113,0.6)', invalid:'rgba(231,76,60,0.6)' }
};

class BlokusGame {
    constructor() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.panels = { 1:document.getElementById('p1-panel'), 2:document.getElementById('p2-panel'), 3:document.getElementById('p3-panel'), 4:document.getElementById('p4-panel') };
        this.trays = { 1:document.getElementById('tray-p1'), 2:document.getElementById('tray-p2'), 3:document.getElementById('tray-p3'), 4:document.getElementById('tray-p4') };
        this.previewOverlay = document.getElementById('preview-overlay');
        this.previewCanvas = document.getElementById('previewCanvas');
        this.gameOverModal = document.getElementById('game-over-modal');
        
        this.board = Array(CONFIG.gridSize).fill().map(()=>Array(CONFIG.gridSize).fill(0));
        this.currentPlayer = 1; 
        this.players = {};
        for(let i=1;i<=4;i++) this.players[i] = { pieces:[...SHAPES], score:89 };
        
        this.selectedPieceIdx = -1;
        this.selectedPieceShape = null; 
        this.consecutivePasses = 0; 
        this.isDragging = false;
        this.dragPos = {x:0, y:0};
        this.cellSize = 0;
        
        // ‚òÖ ÈáçÈªûË®≠ÂÆöÔºöËß∏ÊéßÂÅèÁßªÈáè (ÂÉèÁ¥†)
        // ËÆìÁ©çÊú®ÁúãËµ∑‰æÜÈ£ÑÂú®ÊâãÊåá‰∏äÊñπÔºåÁ¥Ñ 80px
        this.touchOffsetY = 80;

        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', ()=>this.resize());
        this.bindEvents();
        this.renderTrays();
        this.updateTurnVisuals();
        this.showMsg(`P1 (Ëóç) ÂõûÂêà`);
    }

    resize() {
        const c = document.getElementById('center-panel');
        const minDim = Math.min(c.clientWidth, c.clientHeight - 80);
        this.canvas.width = minDim;
        this.canvas.height = minDim;
        this.cellSize = this.canvas.width / CONFIG.gridSize;
        this.draw();
    }

    draw() {
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        
        // 1. Á∂≤Ê†º
        for(let r=0;r<CONFIG.gridSize;r++){
            for(let c=0;c<CONFIG.gridSize;c++){
                const x=c*this.cellSize, y=r*this.cellSize;
                if(this.board[r][c]!==0) this.drawCell(c,r,CONFIG.colors[this.board[r][c]]);
                else { this.ctx.strokeStyle=CONFIG.colors.grid; this.ctx.strokeRect(x,y,this.cellSize,this.cellSize); }
            }
        }
        // 2. Ëµ∑Èªû
        CONFIG.startPoints.forEach((pt,i)=>{
            if(this.board[pt.r][pt.c]===0) {
                const x=pt.c*this.cellSize+this.cellSize/2, y=pt.r*this.cellSize+this.cellSize/2;
                this.ctx.beginPath(); this.ctx.arc(x,y,this.cellSize/3,0,Math.PI*2);
                this.ctx.fillStyle=CONFIG.colors[i+1]; this.ctx.globalAlpha=0.4; this.ctx.fill(); this.ctx.globalAlpha=1;
            }
        });

        // 3. ÊãñÊõ≥ÊïàÊûú (ÈóúÈçµ‰øÆÊ≠£Ëôï)
        if (this.isDragging && this.selectedPieceShape) {
            
            // ‚òÖ Ë®àÁÆó„ÄåÊúâÊïàÂ∫ßÊ®ô„ÄçÔºöÊâãÊåáÂ∫ßÊ®ô - ÂÅèÁßªÈáè
            // ÈÄôÊ®£ÈÇèËºØÂà§Êñ∑(Ê†ºÂ≠ê)ÂíåË¶ñË¶∫È°ØÁ§∫(ÂàÜË∫´)ÊâçÊúÉÂú®Âêå‰∏ÄÂÄã‰ΩçÁΩÆ
            const effectiveX = this.dragPos.x;
            const effectiveY = this.dragPos.y - this.touchOffsetY;

            // A. Á∂≤Ê†º‰∏äÁöÑÂê∏ÈôÑÊÆòÂΩ± (Snap Ghost)
            // ‰ΩøÁî® effectiveY ÈÄ≤Ë°åÊ†ºÂ≠êË®àÁÆó
            const gridPos = this.getGridPosFromScreen(effectiveX, effectiveY);
            const validation = this.validateMove(gridPos.r, gridPos.c, this.selectedPieceShape, this.currentPlayer);
            const ghostColor = validation.valid ? CONFIG.colors.valid : CONFIG.colors.invalid;

            this.selectedPieceShape.forEach(block => {
                const tr = gridPos.r + block[0], tc = gridPos.c + block[1];
                const px = tc * this.cellSize, py = tr * this.cellSize;
                this.ctx.fillStyle = ghostColor;
                this.ctx.fillRect(px, py, this.cellSize, this.cellSize);
                this.ctx.strokeStyle = '#fff'; this.ctx.lineWidth = 2;
                this.ctx.strokeRect(px, py, this.cellSize, this.cellSize);
                this.ctx.lineWidth = 1;
            });

            // B. ÊåáÂ∞ñË∑üÈö®ÂàÜË∫´ (Floating Avatar)
            // Ë¶ñË¶∫‰∏äÁπ™Ë£ΩÂú®ÊâãÊåá‰∏äÊñπÔºåÁõ¥Êé•Â∞çÊáâ gridPos
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            // ËΩâÊàê Canvas ÂÖßÈÉ®Â∫ßÊ®ô
            const cvsX = (effectiveX - rect.left) * scaleX;
            const cvsY = (effectiveY - rect.top) * scaleY;

            this.ctx.save();
            this.ctx.shadowColor="rgba(0,0,0,0.5)"; this.ctx.shadowBlur=15; this.ctx.shadowOffsetY=10;
            
            this.selectedPieceShape.forEach(block => {
                const bx = block[1]*this.cellSize, by = block[0]*this.cellSize;
                // Áï´Âú®ÊúâÊïàÂ∫ßÊ®ô‰∏ä (ÈÄôË£°‰∏çÈúÄË¶ÅÂÜçÊ∏õ touchOffsetYÔºåÂõ†ÁÇ∫ effectiveY Â∑≤Á∂ìÊ∏õÈÅé‰∫Ü)
                const dx = cvsX + bx - this.cellSize/2;
                const dy = cvsY + by - this.cellSize/2;
                
                this.ctx.fillStyle = CONFIG.colors[this.currentPlayer];
                this.ctx.fillRect(dx, dy, this.cellSize*0.9, this.cellSize*0.9);
                this.ctx.strokeStyle="white";
                this.ctx.strokeRect(dx, dy, this.cellSize*0.9, this.cellSize*0.9);
            });
            this.ctx.restore();
        }
    }

    drawCell(c,r,color) {
        const x=c*this.cellSize, y=r*this.cellSize;
        this.ctx.fillStyle=color; this.ctx.fillRect(x+1,y+1,this.cellSize-2,this.cellSize-2);
        this.ctx.fillStyle='rgba(255,255,255,0.3)'; this.ctx.fillRect(x+1,y+1,this.cellSize-2,this.cellSize/2);
    }

    renderTrays() { for(let i=1;i<=4;i++) this.renderSingleTray(i,this.trays[i]); }
    renderSingleTray(pNum, container) {
        container.innerHTML='';
        this.players[pNum].pieces.forEach((shape,idx)=>{
            const div = document.createElement('div');
            div.className = `piece-item ${this.currentPlayer===pNum && this.selectedPieceIdx===idx ? 'selected':''}`;
            div.onclick=()=>{ if(this.currentPlayer===pNum) this.selectPiece(idx); };
            const cvs = document.createElement('canvas');
            cvs.width=50; cvs.height=50; this.drawPieceOnCanvas(cvs,shape,pNum,8);
            div.appendChild(cvs); container.appendChild(div);
        });
    }

    selectPiece(idx) {
        if(this.selectedPieceIdx===idx) return;
        this.selectedPieceIdx=idx;
        this.selectedPieceShape=JSON.parse(JSON.stringify(this.players[this.currentPlayer].pieces[idx]));
        this.renderTrays(); this.renderPreviewBox();
    }

    renderPreviewBox() {
        if(this.selectedPieceIdx===-1) { this.previewOverlay.classList.remove('show'); return; }
        this.previewOverlay.classList.add('show');
        this.previewCanvas.width=100; this.previewCanvas.height=100;
        this.drawPieceOnCanvas(this.previewCanvas, this.selectedPieceShape, this.currentPlayer, 16);
    }

    updateTurnVisuals() {
        for(let i=1;i<=4;i++) {
            this.panels[i].classList.toggle('active', i===this.currentPlayer);
            this.panels[i].classList.toggle('inactive', i!==this.currentPlayer);
        }
        this.previewOverlay.className=''; this.previewOverlay.classList.add(`p${this.currentPlayer}-border`);
        if(window.innerWidth<=900) this.panels[this.currentPlayer].scrollIntoView({behavior:"smooth",inline:"center"});
    }

    drawPieceOnCanvas(cvs,shape,player,sz=12) {
        const ctx=cvs.getContext('2d'); ctx.clearRect(0,0,cvs.width,cvs.height);
        let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
        shape.forEach(([r,c])=>{ if(c<minX)minX=c; if(c>maxX)maxX=c; if(r<minY)minY=r; if(r>maxY)maxY=r; });
        const w=(maxX-minX+1)*sz, h=(maxY-minY+1)*sz;
        const ox=(cvs.width-w)/2-minX*sz, oy=(cvs.height-h)/2-minY*sz;
        ctx.fillStyle=CONFIG.colors[player];
        shape.forEach(([r,c])=>{ 
            ctx.fillRect(ox+c*sz, oy+r*sz, sz-1, sz-1);
            if(cvs.id==='previewCanvas'){ ctx.strokeStyle='#fff'; ctx.strokeRect(ox+c*sz, oy+r*sz, sz-1, sz-1); }
        });
    }

    rotateSelected() { if(this.selectedPieceShape){ this.selectedPieceShape=this.selectedPieceShape.map(([r,c])=>[c,-r]); this.normalizeShape(); this.renderPreviewBox(); this.draw(); } }
    flipSelected() { if(this.selectedPieceShape){ this.selectedPieceShape=this.selectedPieceShape.map(([r,c])=>[r,-c]); this.normalizeShape(); this.renderPreviewBox(); this.draw(); } }
    normalizeShape() {
        let minR=Infinity, minC=Infinity;
        this.selectedPieceShape.forEach(([r,c])=>{ if(r<minR)minR=r; if(c<minC)minC=c; });
        this.selectedPieceShape = this.selectedPieceShape.map(([r,c])=>[r-minR, c-minC]);
    }

    validateMove(gr,gc,shape,p) {
        let coverS=false, corner=false, edge=false, oob=false, overlap=false;
        const st=CONFIG.startPoints[p-1];
        for(let b of shape) {
            const r=gr+b[0], c=gc+b[1];
            if(r<0||r>=CONFIG.gridSize||c<0||c>=CONFIG.gridSize){oob=true;break;}
            if(this.board[r][c]!==0){overlap=true;break;}
            if(r===st.r&&c===st.c)coverS=true;
            [[0,-1],[0,1],[-1,0],[1,0]].forEach(([dr,dc])=>{ 
                const nr=r+dr,nc=c+dc; if(nr>=0&&nr<20&&nc>=0&&nc<20&&this.board[nr][nc]===p)edge=true; 
            });
            [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr,dc])=>{ 
                const nr=r+dr,nc=c+dc; if(nr>=0&&nr<20&&nc>=0&&nc<20&&this.board[nr][nc]===p)corner=true; 
            });
        }
        if(oob||overlap) return {valid:false, reason:'‰ΩçÁΩÆÁÑ°Êïà'};
        if(edge) return {valid:false, reason:'‰∏çËÉΩÈÇäÂ∞çÈÇä'};
        if(this.players[p].score===89) return coverS ? {valid:true} : {valid:false, reason:'ÈúÄËìã‰ΩèËµ∑Èªû'};
        return corner ? {valid:true} : {valid:false, reason:'ÈúÄËßíÂ∞çËßí'};
    }

    placePiece(gr,gc) {
        if(!this.selectedPieceShape)return;
        const res = this.validateMove(gr,gc,this.selectedPieceShape,this.currentPlayer);
        if(res.valid) {
            let pts=0;
            this.selectedPieceShape.forEach(([r,c])=>{ this.board[gr+r][gc+c]=this.currentPlayer; pts++; });
            this.players[this.currentPlayer].pieces.splice(this.selectedPieceIdx,1);
            this.players[this.currentPlayer].score-=pts;
            this.updateScoreUI(); this.consecutivePasses=0; this.switchTurn();
        } else { this.showMsg(res.reason); }
    }

    manualPass() { this.consecutivePasses++; this.checkOver(); }
    switchTurn() {
        this.currentPlayer = (this.currentPlayer%4)+1;
        const names={1:'Ëóç',2:'ÈªÉ',3:'Á¥Ö',4:'Á∂†'};
        this.showMsg(`Êèõ P${this.currentPlayer} (${names[this.currentPlayer]})`);
        this.selectedPieceIdx=-1; this.selectedPieceShape=null;
        this.renderTrays(); this.updateTurnVisuals(); this.draw();
        setTimeout(()=>{
            if(!this.checkMoves(this.currentPlayer)) {
                this.showMsg(`P${this.currentPlayer} ÁÑ°Ë∑ØÂèØËµ∞ Pass`);
                setTimeout(()=>this.manualPass(), 1500);
            }
        },500);
    }
    checkOver(){ if(this.consecutivePasses>=4)this.endGame(); else this.switchTurn(); }
    
    checkMoves(p) {
        if(this.players[p].pieces.length===0)return false;
        for(let s of this.players[p].pieces) {
            let cur=JSON.parse(JSON.stringify(s));
            for(let i=0;i<8;i++) { // Á∞°ÂåñËÆäÁï∞Ê™¢Êü•
                if(i===4) cur=cur.map(([r,c])=>[r,-c]); // flip
                cur=cur.map(([r,c])=>[c,-r]); // rotate
                // Ê≠∏‰∏ÄÂåñ
                let mr=Infinity,mc=Infinity; cur.forEach(([r,c])=>{if(r<mr)mr=r;if(c<mc)mc=c;});
                let norm=cur.map(([r,c])=>[r-mr,c-mc]);
                
                for(let r=0;r<20;r++) for(let c=0;c<20;c++) if(this.validateMove(r,c,norm,p).valid) return true;
            }
        }
        return false;
    }

    endGame() {
        let arr=[]; for(let i=1;i<=4;i++) arr.push({p:i,s:this.players[i].score});
        arr.sort((a,b)=>a.s-b.s);
        const names={1:'Ëóç',2:'ÈªÉ',3:'Á¥Ö',4:'Á∂†'};
        document.getElementById('winner-msg').innerText = `P${arr[0].p} (${names[arr[0].p]}) Áç≤ÂãùÔºÅ`;
        document.getElementById('final-scores').innerHTML = arr.map(x=>`<div>P${x.p}: Ââ©${x.s}Ê†º</div>`).join('');
        this.gameOverModal.classList.add('show');
    }

    updateScoreUI() { for(let i=1;i<=4;i++){ document.getElementById(`s${i}`).innerText=this.players[i].score; document.getElementById(`s${i}-mini`).innerText=this.players[i].score; } }
    showMsg(txt) { const d=document.getElementById('msg-overlay'); d.innerText=txt; d.style.opacity=1; setTimeout(()=>d.style.opacity=0,1500); }

    getGridPosFromScreen(x,y) {
        const r=this.canvas.getBoundingClientRect();
        const sx=this.canvas.width/r.width, sy=this.canvas.height/r.height;
        return { c:Math.floor(((x-r.left)*sx)/this.cellSize), r:Math.floor(((y-r.top)*sy)/this.cellSize) };
    }

    getEventPos(e) {
        if(e.touches&&e.touches.length>0) return {x:e.touches[0].clientX, y:e.touches[0].clientY};
        if(e.changedTouches&&e.changedTouches.length>0) return {x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY};
        return {x:e.clientX, y:e.clientY};
    }

    bindEvents() {
        const start=(e)=>{
            if(e.target.tagName==='BUTTON' || (e.target!==this.canvas && !this.previewOverlay.contains(e.target))) return;
            if(this.selectedPieceIdx===-1) return;
            e.preventDefault(); this.isDragging=true; this.dragPos=this.getEventPos(e); this.draw();
        };
        const move=(e)=>{
            if(!this.isDragging)return;
            if(e.cancelable)e.preventDefault();
            this.dragPos=this.getEventPos(e); this.draw();
        };
        const end=(e)=>{
            if(!this.isDragging)return;
            if(e.cancelable)e.preventDefault();
            this.isDragging=false;
            const pos=this.getEventPos(e);
            
            // ‚òÖ ÈóúÈçµ‰øÆÊ≠£ÔºöÊîæÈñãÊôÇÔºå‰πüË¶Å‰ΩøÁî®„ÄåÊ∏õÂéªÂÅèÁßªÈáè„ÄçÂæåÁöÑÂ∫ßÊ®ô‰æÜÂà§Êñ∑ËêΩÈªû
            const effectiveY = pos.y - this.touchOffsetY;
            
            // ÈÄôË£°Âè™ÈúÄÊ™¢Êü•ÊâãÊåáÊòØÂê¶ÈÇÑÂú® canvas ÈôÑËøëÔºåÊàñÁõ¥Êé•Áî®ÊúâÊïàÂ∫ßÊ®ôË®àÁÆó
            const rect=this.canvas.getBoundingClientRect();
            // ÂØ¨È¨ÜÂà§Êñ∑ÔºöÂè™Ë¶ÅÊâãÊåáÂú® Canvas ÂçÄÂüüÂÖß (Ê∞¥Âπ≥)Ôºå‰∏îÊúâÊïàY‰πüÂú®ÂêàÁêÜÁØÑÂúç
            if(pos.x>=rect.left && pos.x<=rect.right && pos.y>=rect.top && pos.y<=rect.bottom + this.touchOffsetY) {
                const gridPos = this.getGridPosFromScreen(pos.x, effectiveY);
                this.placePiece(gridPos.r, gridPos.c);
            }
            this.draw();
        };

        window.addEventListener('mousedown',start); window.addEventListener('mousemove',move); window.addEventListener('mouseup',end);
        window.addEventListener('touchstart',start,{passive:false}); window.addEventListener('touchmove',move,{passive:false}); window.addEventListener('touchend',end,{passive:false});
    }
}
const game = new BlokusGame();
</script>
</body>
</html>